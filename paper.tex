\documentclass{article}
%\documentclass[twocolumn]{article}%
\usepackage[utf8]{inputenc}%
\usepackage{standalone}%
\usepackage{amsmath}%
\usepackage{amsthm}%
\usepackage{amssymb}%
\usepackage{hyperref}%
\usepackage{xcolor}%
\usepackage{tabularx}%
\usepackage{listings}%
\lstdefinestyle{b}{basicstyle=\tiny\ttfamily}
\lstset{
  showspaces=false,
  showstringspaces=false
  }

% Add your keywords here, and have this in a separate file
% and include it in your preamble
\lstset{emph={%
    function, uint256, public, mapping,contract,bytes,bool, if, for,
    field, private, def, import, assert, require, zksnarkverify %
},emphstyle={\color{blue}\bfseries}%
}

%\definecolor{keywords}{HTML}{8A4A0B}
%
%\definecolor{background}{HTML}{EEEEEE}
%
%\lstset{language=[LaTeX]Tex,
%    keywordstyle=\color{keywords},
%    keywordstyle=[2]\color{red},
%    keywordstyle=[3]\color{orange},
%    basicstyle=\normalfont\ttfamily,
%    showstringspaces=false,
%    frameround=ftff,
%    frame=lines,
%    morekeywords={RequirePackage,ProvidesPackage},
%    keywords=[2]{Some,Other,Keywords},
%    keywords=[3]{and,another,test},
%    backgroundcolor=\color{background}
%}

\newcommand{\khk}{K_{P}}
\newcommand{\khkp}{$K^{-1}[\text{HK}]$}
\newcommand{\kid}{K_{ID}}
%\newcommand{\kid}{$K$}
\newcommand{\todo}[1]{\fbox{\parbox{\linewidth}{\textcolor{red}{#1}}}}
\newcommand{\iv}{$IV(\text{\identity})$}
\newcommand{\sigid}{$K^{-1}[CA](K[Identity])$}
\newtheorem{problem}{Problem}
\newenvironment{solution}
  {\emph{Solution:}}
  {\hfill $\square$}
\newcommand{\pbc}{\textit{Identity Blockchain}}

\title{Proof of Identity}
\author{
Albert Vučinović, University North\\
Miroslav Jerković, University of Zagreb
}
\begin{document}
\maketitle
\section{Notation}
\begin{tabular}{p{0.36\linewidth}|p{0.55\linewidth}}
  $(K, K^{-1})$ & A pair of public $K$ and the corresponding private key $K^{-1}$. \\
	$K(value)$ & $value$ encrypted with a public key $K$. \\
	$K^{-1}(value)$ & $value$ encrypted with a private key $K^{-1}$. \\
  $H$ & Hash function, e.g. some zksnark friedly one \\
	$\kid$ &  State CA certified public key of e.g. eID\\
  $\khk$ & Person key, public key used to access \pbc{} as an unknown Person. \\
  $Nin$ & A personal National Identification Number issued by state.
\end{tabular}

Sometimes we write $K$ for $(K, K^{-1})$.

\newpage
\section{Registering $\khk$}
\begin{enumerate}
  \item Register $\kid$ on \pbc, by calling 
    $$register\kid(H(Nin), \kid^{-1}("register\kid"), proofNinOwnsK).$$
  
    The Person tells the \pbc{} what personal identification document will they be using.

    What is the meaning behind $register\kid$ function?
    \begin{itemize}
      \item Sybil resistance. To prevent a Person from registering more than one $\khk$ using different identification documents, which are issued for the same $Nin$.
      \item Loss of $\kid$. If a Person looses previously registered $\kid$ (e.g. by loosing the eID), they can register a new one.
      \item Identity theft damage control. If a Person overwrites the previous $\kid$ with a new one, the identity thief will loose access to services that check the whole identity chain.
    \end{itemize}

    Entities who know $\kid$ (e.g. CA that issued it) can know that the Person is using \pbc{}, and what identification document the Person is using.

    The reasoning behind the choice of arguments for the $register\kid$ function:

    If we used:
    \begin{itemize}
      \item $register\kid(H(Nin, \kid^{-1}("register\kid")), proofNinOwnsK)$

        TODO: explain
      \item $register\kid(Nin, \kid^{-1}("register\kid"), proofNinOwnsK)$

        TODO: explain
    \end{itemize}

  \item Register $\khk$ on \pbc, by calling 
    $$register\khk(Nin\kid, Nin\kid\khk, proof)$$
  where:
    \begin{enumerate}
      \item $Nin\kid=H(Nin,\kid^{-1}("register\khk"))$
      \item $Nin\kid\khk=H(Nin, \kid^{-1}("register\khk"), \khk^{-1}("register\khk"))$
    \end{enumerate}

  The Person registers a $\khk$, which is a unique public key tied to the Person on the \pbc{}.
  What is the meaning behind $register\khk$ function?
  \begin{itemize}
    \item Sybil resistance. $\khk$ is the only such key that is tied to the Person with the samo $Nin$.
      By design, the Person can not own two valid $\khk$s at the same time.

      TODO: Explanation/proof.
    \item Anonimity. Someone with a database of all the $\kid$ public keys or/and the database of all the $\khk$ public keys, shouldn't be able to determine which $Nin$, $\kid$ or $\khk$ was used, from the function call.

    TODO: Explanation/proof.

    The assumption is that the CA doesn't have access to $\kid^{-1}$, i.e. that $\kid$ is generated safely on the eID.
  \end{itemize}
  The reasoning behind the choice of arguments for the $register\khk$ function:

  TODO: 
\end{enumerate}

\newpage
\section{On chain code}
\begin{lstlisting}[language=C, frame=single, style=b]
//pseudo Solidity
contract IdentitiesManager {
  //all the mappings are mappings where uint256 is a hash!
  mapping(uint256 => uint256) public NinKidUsed;
  mapping(uint256 => uint256) public NinKidKpUsed;
  mapping(uint256 => uint256) public NinKidKpLastConfirmed;
  mapping(uint256 => bool) public KpInvalid;
  mapping(uint256 => bool) public KidInvalid;
  //TODO:CA fields!

  //hNin=H(Nin)
  //vKid=KidPrivate("registerKid")
  function registerKid public(
    uint256 hNin,
    uint256 vKid,
    bytes proofNinOwnsKid
  ){
    uint256 previousKey = NinKidUsed[hNin];
    if(previousKey == vKid)
      return;
    bool isOwner = zksnarkverify(VK, [
        hNin, 
        vKid
      ],
      proofPINOwnsKid);
    if(isOwner && ! KidInvalid[vKid]){
      if(previousKey!=0)
        KidInvalid[previousKey]=true;
      NinKidUsed[hNin]=vKid;
    }
  }

  //look into the paper.pdf for meaning of args
  function registerKp public(
    uint256 NinKid,
    uint256 NinKidKp,
    bytes proof
  ){
    uint256 previousKey = NinKidKpUsed[NinKid]
    if(previousKey == NinKid)
      return; //already registered

    //zkp(
      //K!invalid
        //?Need KInvalid to be Zero Knowledge Set (ZKS), and to get roots
      //CA!invalid
      //CA -> K -> Nin
      //NinKid=H(Nin, KidPrivate("registerP"))
      //NinKidKp=H(Nin, KidPrivate("registerP"), KpPrivate("registerP"))
    //)
    bool ok = zksnarkverify(VK, [
      NinKid,
      NinKidKp
    ], proof);

    if(ok && ! PInvalid[NinKidKp]){
      if(previousKey != 0)
        PInvalid[previousKey]=true;
      NinKidKpUsed[NinKid]=NinKidKp;
      NinKidKpLastConfirmed[NinKid]=block.number;
    }

  }

}

contract PersonAccount{
}
\end{lstlisting}

\newpage
\section{zkp code}
\begin{lstlisting}[language=C, frame=single, style=b]
//pseudo zokrates zk-SNARK
import "hashes/sha256/512bitPacked" as sha256packed
import "ecc/babyjubjubParams.code" as context
import "ecc/proofOfOwnership.code" as proofOfOwnership

def proofPINOwnsK(
  field[2] PINHash,
  field[2] K_1Hash,
  field[2] 

  private field[?] CACert){
}

def proof_of_being_a_person(
  //publically known arguments
  field[2] PINKeyUsedHash,
  field[2] PINKeyPersonKeyIssuedHash,
  field[2] PersonKeyInvalidHash,
  field[2] KeyInvalidHash,

  //BC state
  field BC_PINUsed,//BC State
  field BC_PINKeyUsed,//BC State
  field BC_PINKeyPersonKeyIssued,//BC State
  field BC_PersonKeyInvalid,//BC State
  field BC_KeyInvalid,//BC State
  ?field BC_private_key_challenge?

  //CA keys!
  field[?][?] CAKeys,//? BC State
  ...

  //private data
  //15360 bit RSA key is equivalent to 256-bit symmetric keys
  //2048 bit RSA key is equivalent to 112 bit symmetric keys
  //eID has 2048 bit RSA
  private field PIN,//max 254 bits, using only 128 = 16 bytes
  private field K_private_bc_new,//ECC private key
  private field[?] K_new,//public RSA key from eID
  private field[?] K_1_new,//private RSA key from eID, actually signed message
  //K_1_new("PeopleBC person proof")
  private field K_private_bc_old,//ECC private key, old
  private field[?] K_1_old)//K_1_old("PeopleBC person proof")?
  //?private field[2] K_bc_new,//ECC public key ?no need for key pair verification?
  //?private field[2] K_bc_old,//ECC public key ?no need for key pair verification
  private field[?] CAcert,
  private field CAindex
{
  //actual checking code here
  field[2] hash_PIN = sha256packed([0,0,0,PIN])
  assert(hash_PIN == PINHash);//proving that we know the real PIN, unimportant

  //proving ownership of newly registered key, 
  //no real need to prove ownership of bc key
  //we actually need to prove ownereship of K_1_new, 
  //and its connection to PIN via CA
  context=context()//babyjubjubParams context
  proofOfOwnership(K_bc_new, K_private_bc_new, context)==1

  //prove that you own the K_new
  //pseudo
  RSADecrypt(K_new, K_1_new) == "PeopleBC Person Proof";//?+BC_private_key_challenge;

  //proove that Key is connected to CA
  //pseudo
  checkCASignature(CAKey[CAindex], CACert, K_new) == 1;
  
  //proove that K_new is PIN certificate
  //pseudo
  extractPIN(CACert)==PIN;
  
  //end

  //end..
}
\end{lstlisting}
\newpage
\section{Problems}
\begin{problem}
  The rate of adding identities, the problem being frequent changes of Merkle Tree Roots, and how long it takes to generate zkp proof, and block generation time.
\end{problem}
\begin{problem}
\label{prob:bigsteal}
  Someone stole $K^{-1}$ before we registered on \pbc.
  The Thief registered $K$ and $P$, and who knows what else.
\end{problem}
\begin{solution}
\end{solution}
\begin{problem}
  Someone stole $K^{-1}$ after we registered on \pbc.
\end{problem}
\begin{problem}
Trying to use unregistered Key.
\end{problem}
\begin{solution}
\end{solution}
\begin{problem}
Trying to register the same PIN with multiple Keys (e.g. two physical ids).
\end{problem}
\begin{problem}
\label{prob:chain}
  Using $P$ without checking the whole $CA\rightarrow K\rightarrow P$ chain.
  \begin{itemize}
    \item Using $P$ to register as a mining key.
    \item Invalidating $P$.
    \item Using $P_{new}$ as a mining key.
  \end{itemize}
\end{problem}
\begin{solution}
  Look at the solution to Problem \ref{prob:miningKey}.

  The Mining Registry can accept new $P$s after an expiration period (which can also be e.g. 1 day).
\end{solution}
\begin{problem}
\label{prob:miningKey}
  A combination of Problem \ref{prob:bigsteal} and Problem \ref{prob:chain}.
  Someone steals $K$, registeres $P$ and registeres $P$ for mining.
  The problem is bigger, because we can't invalidate $P$ if we don't know which $P$ it is.
\end{problem}
\begin{solution}
  We make $P$ renewable. We write the last block number it was renewed on to the blockchain.
  Mining Registry can choose to accept P which is not older than some time period (for the Registry a good period would seem to be 1 day).
  When paying the miners, the Registry also requires proof of $P$'s age.

  $K$ is easely invalidated, because there is an explicit $PIN \rightarrow K^{-1}$ mapping on the blockchain, so it doesn't need to be renewable in the sence to proove it is still valid.
\end{solution}
\begin{problem}
  Only $P$ compromised.
\end{problem}
\end{document}
